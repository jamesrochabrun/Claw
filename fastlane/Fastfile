# frozen_string_literal: true

default_platform(:mac)

# Load secrets from environment or keychain
require "base64"

# Execute a shell command silently
def silent_sh(command)
  sh(command, log: false)
rescue
  ""
end

# Load a secret from environment variable or keychain
def load_secret(env_key)
  if ENV[env_key]
    unless ENV["CI"]
      # Store in keychain for future use (locally)
      puts "Writing secret to keychain: #{env_key}"
      sh("security add-generic-password -a '#{ENV["USER"]}' -s 'com.claw.#{env_key}' -w '#{Base64.strict_encode64(ENV[env_key])}' -U")
    end
    return ENV[env_key]
  end

  puts "Loading secret from keychain: #{env_key}"
  encoded = %x(security find-generic-password -s 'com.claw.#{env_key}' -w 2>/dev/null).strip
  return if encoded.empty?

  decoded = Base64.decode64(encoded)
  ENV[env_key] = decoded
end

# Find available version that doesn't conflict
def find_available_version(initial_version)
  version = initial_version

  loop do
    existing_tag = silent_sh("git ls-remote origin refs/tags/v#{version}").strip
    existing_branch = silent_sh("git ls-remote origin refs/heads/release-v#{version}").strip

    # Check if GitHub release exists
    existing_release = begin
      http_status = silent_sh("curl -o /dev/null -s -w '%{http_code}' https://github.com/jamesrochabrun/Claw/releases/tag/v#{version}").strip
      http_status == "200"
    rescue
      false
    end

    if existing_tag.empty? && existing_branch.empty? && !existing_release
      puts "Using version: #{version}"
      return version
    else
      conflicts = []
      conflicts << "tag" unless existing_tag.empty?
      conflicts << "branch" unless existing_branch.empty?
      conflicts << "release" if existing_release

      version_parts = version.split(".")
      version_parts[-1] = (version_parts[-1].to_i + 1).to_s
      new_version = version_parts.join(".")
      puts "Version #{version} conflicts with existing #{conflicts.join(", ")}. Bumping to #{new_version}."
      version = new_version
    end
  end
end

platform :mac do
  desc "Build the app in Debug configuration"
  lane :build_debug do
    build_mac_app(
      project: "./Claw.xcodeproj",
      configuration: "Debug",
      skip_archive: true,
      scheme: "Claw",
      xcodebuild_formatter: "xcbeautify --quiet",
    )
  end

  desc "Build the app in Release configuration"
  lane :build_release do
    setup_ci if ENV["CI"]

    build_path = File.absolute_path("../build")

    # Resolve package dependencies
    sh("xcodebuild -resolvePackageDependencies -scheme Claw -project ../Claw.xcodeproj -configuration Release -derivedDataPath #{build_path}/derived_data -parallelizeTargets")

    build_mac_app(
      destination: "platform=macOS,arch=arm64",
      skip_package_dependencies_resolution: true,
      project: "./Claw.xcodeproj",
      configuration: "Release",
      output_directory: "#{build_path}/release",
      derived_data_path: "#{build_path}/derived_data",
      output_name: "Claw.app",
      scheme: "Claw",
      skip_archive: true,
      skip_codesigning: true,
      xcodebuild_formatter: "xcbeautify --quiet",
    )
  end

  desc "Build, sign, notarize and create Sparkle update"
  lane :create_and_sign_release do |options|
    setup_ci if ENV["CI"]

    build_path = File.absolute_path("../build")
    sh("rm -rf #{build_path}")

    # Resolve package dependencies
    sh("xcodebuild -resolvePackageDependencies -scheme Claw -project ../Claw.xcodeproj -configuration Release -derivedDataPath #{build_path}/derived_data -parallelizeTargets")

    version = options.fetch(:version, nil)

    # Load secrets
    personal_github_access_token = load_secret("FASTLANE_GITHUB_ACCESS_TOKEN")

    # Skip Match - use existing local certificate
    # Certificate already installed: Developer ID Application: James Rochabrun (YOUR_TEAM_ID)
    update_code_signing_settings(
      code_sign_identity: "Developer ID Application",
      use_automatic_signing: false,
      path: "./Claw.xcodeproj",
    )

    # Use existing certificate
    certificate_name = "Developer ID Application"
    certificate_sha1 = "YOUR_CERTIFICATE_SHA1"

    app_name = "Claw"
    app_path = "#{build_path}/release/#{app_name}.app"
    archive_path = "#{build_path}/release/#{app_name}.xcarchive"

    # Build and archive
    build_mac_app(
      destination: "platform=macOS,arch=arm64",
      skip_package_dependencies_resolution: true,
      project: "./Claw.xcodeproj",
      configuration: "Release",
      export_method: "developer-id",
      output_directory: "#{build_path}/release",
      archive_path: archive_path,
      derived_data_path: "#{build_path}/derived_data",
      output_name: app_name,
      scheme: "Claw",
      skip_archive: false,
      xcodebuild_formatter: "xcbeautify --quiet",
    )

    # Strip debug symbols and resign
    app_binary_path = "#{app_path}/Contents/MacOS/Claw"
    strip_debug_symbols_and_resign(
      app_path: app_path,
      app_binary_path: app_binary_path,
      build_path: build_path,
      certificate_name: certificate_name,
      certificate_sha1: certificate_sha1
    )

    # Notarize
    app_store_connect_api_key(
      key_id: load_secret("NOTARY_KEY_ID"),
      issuer_id: load_secret("NOTARY_ISSUER_ID"),
      key_content: load_secret("NOTARY_P8"),
    )
    notarize(
      package: app_path,
      verbose: false,
      print_log: true,
      use_notarytool: true,
    )

    # Create DMG
    dmg_path = "#{build_path}/release/#{app_name}.dmg"
    sh("cd #{build_path}/release && create-dmg '#{app_name}.app' --identity #{certificate_sha1} --no-version-in-filename --overwrite")
    sh("cd #{build_path}/release && mv #{app_name}.dmg #{app_name}.dmg 2>/dev/null || true")

    # Verify signatures
    puts "Verifying code signature..."
    sh("codesign --verify --deep --strict --verbose=2 '#{app_path}'")
    sh("spctl -a -t exec -vv '#{app_path}'")
    sh("codesign --verify --deep --strict --verbose=2 '#{dmg_path}'")

    # Create Sparkle update ZIP
    app_zip_path = "#{app_path}.zip"
    sh("ditto -c -k --keepParent --sequesterRsrc #{app_path} #{app_zip_path}")

    sparkle_path = "#{build_path}/derived_data/SourcePackages/artifacts/sparkle/Sparkle"
    sparkle_secret_key = load_secret("SPARKLE_SECRET_KEY")

    sparkle_output = sh("echo '#{sparkle_secret_key}' | #{sparkle_path}/bin/sign_update #{app_zip_path} --ed-key-file -")

    # Get version from xcconfig
    xcconfig_path = File.absolute_path("../Claw.xcconfig")
    version ||= sh("cat #{xcconfig_path} | grep APP_VERSION=").split("APP_VERSION = ").last.strip

    puts "Build completed successfully. version: #{version}, app_path: #{app_path}"

    # Update appcast
    appcast_template_path = File.absolute_path("../appcast.template.xml")
    appcast_path = File.absolute_path("../appcast.xml")
    appcast_content = File.read(appcast_template_path)

    # Get file size
    zip_size = File.size(app_zip_path)
    current_date = Time.now.strftime("%a, %d %b %Y %H:%M:%S %z")

    appcast_content.gsub!("REPLACE_VERSION", version)
    appcast_content.gsub!("REPLACE_DESCRIPTION", "Release version #{version}")
    appcast_content.gsub!("REPLACE_PUBDATE", current_date)
    appcast_content.gsub!("REPLACE_SIGNATURE", sparkle_output.strip)
    appcast_content.gsub!("REPLACE_LENGTH", zip_size.to_s)

    File.write(appcast_path, appcast_content)

    {
      version: version,
      app_zip_path: app_zip_path,
      app_binary_path: app_binary_path,
      build_path: build_path,
      dmg_path: dmg_path,
      archive_path: archive_path
    }
  end

  desc "Build, sign, and distribute release with GitHub PR"
  lane :distribute_release do |options|
    setup_ci if ENV["CI"]

    # Set distribution channel to stable
    xcconfig_path = File.absolute_path("../Claw.xcconfig")
    sh("sed -i '' 's/APP_DISTRIBUTION_CHANNEL = .*/APP_DISTRIBUTION_CHANNEL = stable/' #{xcconfig_path}")

    original_version = sh("cat #{xcconfig_path} | grep APP_VERSION =").split("APP_VERSION = ").last.strip
    version = find_available_version(original_version)

    # Update version if changed
    if version != original_version
      sh("sed -i '' 's/APP_VERSION = #{original_version}/APP_VERSION = #{version}/' #{xcconfig_path}")
    end

    # Create and sign release
    result = create_and_sign_release(version: version)
    version = result[:version]
    app_zip_path = result[:app_zip_path]
    dmg_path = result[:dmg_path]

    # Create GitHub Release
    gh_token = load_secret("GH_WRITE_TOKEN")
    set_github_release(
      api_token: gh_token,
      server_url: "https://api.github.com",
      repository_name: "jamesrochabrun/Claw",
      name: "v#{version}",
      tag_name: "v#{version}",
      description: "Release v#{version}",
      commitish: "main",
      upload_assets: [dmg_path, app_zip_path],
    )

    # Create PR with changes
    current_branch = sh("git rev-parse --abbrev-ref HEAD").strip
    new_branch_name = "release-v#{version}"
    sh("git add ../..  && git commit -m 'Release v#{version}' --no-verify && git checkout -b #{new_branch_name} && git push origin #{new_branch_name} --no-verify")

    create_pull_request(
      api_token: gh_token,
      title: "Release v#{version}",
      repo: "jamesrochabrun/Claw",
      head: new_branch_name,
      base: "main",
    )

    sh("git checkout #{current_branch}")
  end

  desc "Strip debug symbols and resign the app"
  lane :strip_debug_symbols_and_resign do |options|
    app_binary_path = options.fetch(:app_binary_path, nil)
    app_path = options.fetch(:app_path, nil)
    build_path = options.fetch(:build_path, nil)
    certificate_name = options.fetch(:certificate_name, nil)
    certificate_sha1 = options.fetch(:certificate_sha1, nil)

    # Extract entitlements
    entitlements_path = "#{build_path}/extracted_entitlements.plist"
    sh("codesign -d --entitlements :- '#{app_path}' > '#{entitlements_path}'")

    # Strip debug symbols
    sh("strip -rSTx '#{app_binary_path}'")

    # Find and strip all Mach-O binaries
    Dir.glob("#{app_path}/**/*").each do |file|
      next unless File.file?(file) && !File.symlink?(file)

      file_type = begin
        silent_sh("file -b '#{file}'")
      rescue
        ""
      end
      next unless file_type.include?("Mach-O") && !file_type.include?("dSYM")

      puts "Stripping: #{file}"
      begin
        silent_sh("strip -rSTx '#{file}'")
      rescue
        puts "Warning: Could not strip #{file}"
      end
    end

    puts "Using certificate to resign: #{certificate_name} (#{certificate_sha1})"

    # Find signable components (deepest first)
    all_components = []

    # Find bundles and frameworks
    Dir.glob("#{app_path}/**/*.{framework,appex,bundle,xpc,app}").each do |component|
      next if component == app_path
      depth = component.split("/").length
      all_components << { path: component, depth: depth }
    end

    # Find standalone binaries (like ApprovalMCPServer)
    Dir.glob("#{app_path}/**/*").each do |file|
      next unless File.file?(file) && !File.symlink?(file)
      next if file.end_with?('.framework', '.appex', '.bundle', '.xpc', '.app')

      file_type = begin
        silent_sh("file -b '#{file}'")
      rescue
        ""
      end

      if file_type.include?("Mach-O") && !file_type.include?("dSYM")
        depth = file.split("/").length
        all_components << { path: file, depth: depth }
      end
    end

    # Sort by depth (deepest first)
    all_components.sort_by! { |c| [-c[:depth], c[:path]] }

    # Sign each component
    all_components.each do |component|
      component_name = File.basename(component[:path])
      puts "Signing: #{component_name}"

      temp_entitlements = "#{build_path}/#{component_name.gsub(/[^\w.-]/, "_")}_entitlements.plist"
      begin
        silent_sh("codesign -d --entitlements :- '#{component[:path]}' > '#{temp_entitlements}' 2>/dev/null")
      rescue
        nil
      end

      if File.exist?(temp_entitlements) && File.size(temp_entitlements) > 0
        silent_sh("codesign --force --sign #{certificate_sha1} --options runtime --timestamp --entitlements '#{temp_entitlements}' '#{component[:path]}'")
      else
        silent_sh("codesign --force --sign #{certificate_sha1} --options runtime --timestamp '#{component[:path]}'")
      end

      silent_sh("rm -f '#{temp_entitlements}'")
    end

    # Sign main app
    puts "Signing: #{app_path}"
    silent_sh("codesign --force --sign #{certificate_sha1} --options runtime --timestamp --entitlements '#{entitlements_path}' '#{app_path}'")
    silent_sh("rm '#{entitlements_path}'")
  end
end
